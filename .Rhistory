div(
style = "display: flex; flex-wrap: wrap; gap: 10px;",
lapply(1:nrow(plotdata), function(j) {
div(
style = "flex: 1 0 100px; max-width: 130px;",
valueBox(
value = round(plotdata$mediane[j], 1),
subtitle =  paste("médiane :", plotdata$group[j]),
icon = icon("circle-info"),
color = "aqua",
width = NULL
)
)
})
)
})
})
###Analyse de Texte
# 1. Génération dynamique des interfaces par fichier
output$texte_blocks_ui <- renderUI({
req(data_reactive())
n <- length(data_reactive())
fichiers <- fichiers_excel()$name
box_width <- if (n == 1) 12 else 6
blocs <- lapply(seq_len(n), function(i) {
df <- data_reactive()[[i]]
# Colonnes contenant "[Autres]" dans le nom
autres_cols <- names(df)[grepl("\\[Autres?.*?\\]", names(df), ignore.case = TRUE)|
grepl("\\[Commentaires?.*?\\]", names(df), ignore.case = TRUE)]
# Colonnes avec > 15 modalités uniques (en excluant les NA)
vars_plus_15_modalites <- names(df)[sapply(df, function(col) {
is.character(col) || is.factor(col)
}) & sapply(df, function(col) {
length(unique(na.omit(col))) > 15
})]
# Combinaison des deux (sans doublons)
colonnes_texte <- unique(c(autres_cols, vars_plus_15_modalites))
box(
title = paste("Fichier :", fichiers[i]),
width = box_width, status = "info", solidHeader = TRUE,
selectInput(paste0("question_texte_autres_", i), "Variable contenant du texte :", choices = colonnes_texte),
uiOutput(paste0("liste_reponses_autres_", i)),
plotOutput(paste0("nuage_mots_", i)),
uiOutput(paste0("table_mots_", i))
)
})
# Affichage en une ou deux colonnes selon le nombre
if (n == 1) {
tagList(blocs)
} else {
rows <- lapply(seq(1, length(blocs), by = 2), function(i) {
fluidRow(
blocs[[i]],
if ((i + 1) <= length(blocs)) blocs[[i + 1]] else NULL
)
})
tagList(rows)
}
})
lapply(1:5, function(i) {
output[[paste0("liste_reponses_autres_", i)]] <- renderUI({
req(input[[paste0("question_texte_autres_", i)]], data_reactive()[[i]])
df <- data_reactive()[[i]]
reponses <- df[[input[[paste0("question_texte_autres_", i)]]]]
reponses <- na.omit(reponses)
reponses <- reponses[reponses != ""]
if (length(reponses) == 0) {
return(h4("Aucune réponse disponible pour cette question."))
}
tagList(
h4(paste("Réponses à :", input[[paste0("question_texte_autres_", i)]])),
div(style = "max-height: 500px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;",
lapply(seq_along(reponses), function(j) {
div(style = "margin-bottom: 10px; padding: 8px; border-bottom: 1px solid #ddd;",
strong(paste0("Réponse ", j, " : ")),
span(reponses[[j]]))
}))
)
})
output[[paste0("nuage_mots_", i)]] <- renderPlot({
req(input[[paste0("question_texte_autres_", i)]], data_reactive()[[i]])
df <- data_reactive()[[i]]
reponses <- df[[input[[paste0("question_texte_autres_", i)]]]]
reponses <- na.omit(reponses)
reponses <- reponses[reponses != ""]
if (length(reponses) == 0) return(NULL)
texte <- corpus(reponses)
texte <- tokens(texte, what = "word", remove_punct = TRUE)
texte <- tokens_remove(texte, stopwords("french"), padding = FALSE)
texte <- dfm(texte)
textplot_wordcloud(texte, max_words = 30, scale = c(7, 0.8), color = c('pink', 'orange', 'red'))
})
# UI + scroll autour du tableau
output[[paste0("table_mots_", i)]] <- renderUI({
div(
style = "max-height: 300px; overflow-y: auto; border: 1px solid #ccc; padding: 10px;",
tableOutput(paste0("table_mots_rempli", i))
)
})
output[[paste0("table_mots_rempli", i)]] <- renderTable({
req(input[[paste0("question_texte_autres_", i)]], data_reactive()[[i]])
df <- data_reactive()[[i]]
reponses <- df[[input[[paste0("question_texte_autres_", i)]]]]
reponses <- na.omit(reponses)
reponses <- reponses[reponses != ""]
if (length(reponses) == 0) return(NULL)
texte <- corpus(reponses)
texte <- tokens(texte, what = "word", remove_punct = TRUE)
texte <- tokens_remove(texte, stopwords("french"), padding = FALSE)
texte <- dfm(texte)
freq <- textstat_frequency(texte, n = 20)
table_df <- freq[, c("feature", "frequency")]
colnames(table_df) <- c("Mot", "Nombre d'apparition")
table_df
})
})
###################################################################
##Analyse de Profils
###################################################################
data_list <- data_reactive
output$profil_blocks_ui <- renderUI({
req(data_list())
lapply(seq_along(data_list()), function(i) {
ns <- function(id) paste0("profil", i, "_", id)
# Nom du fichier ou de la data.frame
fichier <- fichiers_excel()$name[i]
box(
title = paste("Analyse des profils -", fichier),  # Utilisation du nom du fichier
width = 12, status = "primary", solidHeader = TRUE,
selectizeInput(ns("var_actives"), "Variables actives :",
choices = questions_quali_list()[[i]], multiple = TRUE),
uiOutput(ns("modalite_ui")),
selectizeInput(ns("var_supplementaires"), "Variables supplémentaires :", choices = questions_quali_list()[[i]], multiple = TRUE),
radioButtons(ns("radio"), "Gestion des valeurs manquantes :", choices = list(
"Avec valeurs manquantes" = 1,
"Supprimer" = 2,
"Remplacer" = 3
)),
htmlOutput(ns("nb_lignes_supprimees_text")),
checkboxInput(ns("filtrer_distance"),
"Afficher uniquement les modalités avec distance > 1",
value = FALSE),
tagList(
h4("Graphe ACM — Profil 1"),
plotlyOutput(ns("graphe_profil1")),
h4("Graphe ACM — Profil 2"),
plotlyOutput(ns("graphe_profil2"))
)
)
})
})
observeEvent(data_list(), {
nb_fichiers <- length(data_list())
lapply(seq_len(nb_fichiers), function(i) {
local({
my_i <- i
ns <- function(id) paste0("profil", my_i, "_", id)
vals_acm <- reactiveValues(actives = character(), supplementaires = character())
modalites_memoires <- reactiveValues()
output[[ns("modalite_ui")]] <- renderUI({
req(input[[ns("var_actives")]], data_list()[[my_i]], questions_quali_list()[[my_i]])
df <- data_list()[[my_i]]
question_list <- questions_quali_list()[[my_i]]
selected_labels <- input[[ns("var_actives")]]
if (length(selected_labels) == 0) return(NULL)
ui_list <- lapply(selected_labels, function(lbl) {
code <- lbl
if (is.null(code) || is.na(code)) return(NULL)
cols_found <- names(df)[startsWith(names(df), code)]
cols_found <- cols_found[!stringr::str_detect(cols_found, regex("\\[Autres?.*?\\]", ignore_case = TRUE))]
cols_found <- cols_found[!stringr::str_detect(cols_found, regex("\\[Commentaires?.*?\\]", ignore_case = TRUE))]
if (length(cols_found) > 1) {
id_input <- paste0("modalite_", code)
selectizeInput(inputId = ns(id_input),
label = paste0("Modalités spécifiques pour ", lbl, " :"),
choices = setNames(cols_found, cols_found),
selected = isolate(modalites_memoires[[id_input]]),
multiple = TRUE)
} else NULL
})
do.call(tagList, ui_list)
})
observe({
req(input[[ns("var_actives")]])
question_list <- questions_quali_list()[[my_i]]
for (lbl in input[[ns("var_actives")]]) {
code <- lbl
if (is.null(code)) next
id_input <- paste0("modalite_", code)
observeEvent(input[[ns(id_input)]], {
modalites_memoires[[id_input]] <- input[[ns(id_input)]]
}, ignoreNULL = FALSE)
}
})
observe({
req(questions_quali_list()[[my_i]])
choix <- questions_quali_list()[[my_i]]
updateSelectizeInput(session, ns("var_actives"), choices = choix, server = TRUE)
updateSelectizeInput(session, ns("var_supplementaires"), choices = choix, server = TRUE)
})
modalites_selectionnees <- reactive({
req(input[[ns("var_actives")]], questions_quali_list()[[my_i]])
question_list <- questions_quali_list()[[my_i]]
selected_labels <- input[[ns("var_actives")]]
res <- list()
for (lbl in selected_labels) {
code <- lbl
if (is.null(code)) next
id_input <- paste0("modalite_", code)
val <- modalites_memoires[[id_input]]
if (!is.null(val) && length(val) > 0) res[[code]] <- val
}
return(res)
})
rename_columns_for_display <- function(noms) {
sapply(noms, function(nom) {
# Extraire la partie avant le premier crochet → code question
code_question <- sub("\\[.*", "", nom)
code_question <- trimws(code_question)  # Nettoyage espaces
# Extraire tous les contenus entre crochets
matches <- stringr::str_match_all(nom, "\\[([^\\]]+)\\]")[[1]]
# Si on a au moins deux crochets, on prend le contenu du 2e
if (nrow(matches) >= 2) {
libelle_modalite <- matches[2, 2]
return(paste0(code_question, ".[", libelle_modalite, "]"))
} else {
return(nom)  # Pas deux crochets : on garde tel quel
}
}, USE.NAMES = FALSE)
}
donnees_modifiees <- reactive({
req(data_list()[[my_i]], input[[ns("var_actives")]], questions_quali_list()[[my_i]])
df <- data_list()[[my_i]]
question_list <- questions_quali_list()[[my_i]]
selection_modalites <- modalites_selectionnees()
actives_cols <- character(0)
supp_cols <- character(0)
# Collecte des colonnes actives
for (lbl in input[[ns("var_actives")]]) {
code <- lbl
if (!is.null(selection_modalites[[code]])) {
actives_cols <- c(actives_cols, selection_modalites[[code]])
} else {
cols_found <- names(df)[startsWith(names(df), code)]
cols_found <- cols_found[!stringr::str_detect(cols_found, regex("\\[Autres?.*?\\]", ignore_case = TRUE))&
!stringr::str_detect(cols_found, regex("\\[Commentaires?.*?\\]", ignore_case = TRUE))]
actives_cols <- c(actives_cols, cols_found)
}
}
# Collecte des colonnes supplémentaires
if (!is.null(input[[ns("var_supplementaires")]])) {
for (lbl in input[[ns("var_supplementaires")]]) {
code <- lbl
if (!is.null(selection_modalites[[code]])) {
supp_cols <- c(supp_cols, selection_modalites[[code]])
} else {
cols_found <- names(df)[startsWith(names(df), code)]
cols_found <- cols_found[!stringr::str_detect(cols_found, regex("\\[Autres?.*?\\]", ignore_case = TRUE))&
!stringr::str_detect(cols_found, regex("\\[Commentaires?.*?\\]", ignore_case = TRUE))]
supp_cols <- c(supp_cols, cols_found)
}
}
}
df <- df[, unique(c(actives_cols, supp_cols)), drop = FALSE]
# Traitement des valeurs manquantes
df[] <- lapply(df, function(col) {
if (is.character(col) || is.factor(col)) {
col[col %in% c("N/A", "null")] <- NA
return(as.factor(col))
} else col
})
# Gestion des valeurs manquantes selon le choix
mode_na <- input[[ns("radio")]]
if (mode_na == 2) {
nb_avant <- nrow(df)
df_clean <- na.omit(df)
nb_supprimees <- nb_avant - nrow(df_clean)
vals_acm$nb_lignes_supprimees <- nb_supprimees
vals_acm$nb_lignes_initial <- nb_avant
colnames(df_clean) <- rename_columns_for_display(colnames(df_clean))
vals_acm$actives <- rename_columns_for_display(actives_cols)
vals_acm$supplementaires <- rename_columns_for_display(supp_cols)
return(df_clean)
}
if (mode_na == 3) df <- imputeMCA(df,ncp=3)$completeObs
colnames(df) <- rename_columns_for_display(colnames(df))
vals_acm$actives <- rename_columns_for_display(actives_cols)
vals_acm$supplementaires <- rename_columns_for_display(supp_cols)
return(df)
})
acm_resultats <- reactive({
df <- donnees_modifiees()
req(ncol(df) > 0, length(vals_acm$actives) > 0)
MCA(df,
quali.sup = if (length(vals_acm$supplementaires) > 0)
which(colnames(df) %in% vals_acm$supplementaires)
else NULL,
graph = FALSE)
})
output[[ns("nb_lignes_supprimees_text")]] <- renderUI({
HTML(paste0(
"Nombre de lignes supprimées (valeurs manquantes) : ",
"<span style='color:red;'>", vals_acm$nb_lignes_supprimees, "</span>",
" sur ",
"<span style='color:red;'>", vals_acm$nb_lignes_initial, "</span>"
))
})
# Graphe Profil 1
output[[ns("graphe_profil1")]] <- renderPlotly({
res <- acm_resultats()
validate(
need(!is.null(res), "Impossible de réaliser l'ACM : vérifiez vos sélections.")
)
var_coords_actives <- as.data.frame(res$var$coord)
if (!is.null(res$quali.sup) && !is.null(res$quali.sup$coord) && nrow(res$quali.sup$coord) > 0) {
var_coords_sup <- as.data.frame(res$quali.sup$coord)
var_coords <- rbind(var_coords_actives, var_coords_sup)
var_coords$type <- c(rep("Active", nrow(var_coords_actives)),
rep("Supplémentaire", nrow(var_coords_sup)))
} else {
var_coords <- var_coords_actives
var_coords$type <- "Active"
}
colnames(var_coords) <- gsub(" ", ".", colnames(var_coords))
var_coords$label <- rownames(var_coords)
var_coords$distance <- sqrt(var_coords$Dim.1^2 + var_coords$Dim.2^2)
if (isTRUE(input[[ns("filtrer_distance")]])) {
var_coords <- subset(var_coords, distance > 1)
}
validate(
need(nrow(var_coords) > 0, "Aucune modalité avec une distance > 1.")
)
palette_couleur <- c(
"Active" = "blue",
"Supplémentaire" = "darkred"
)
p <- fviz_mca_biplot(res,
label = "none",
col.var = NA,
col.ind = "grey",
axes = c(1, 2),
repel = TRUE)
p$layers <- Filter(function(layer) {
!inherits(layer$geom, "GeomPoint") || !any(grepl("var", deparse(layer$mapping)))
}, p$layers)
p <- p +
geom_point(data = var_coords,
aes(x = Dim.1, y = Dim.2, color = type, shape = type),
size = 2) +
geom_text(data = var_coords,
aes(x = Dim.1, y = Dim.2, label = label, color = type),
size = 3, vjust = -1.8) +
scale_color_manual(values = palette_couleur) +
scale_shape_manual(values = c("Active" = 16, "Supplémentaire" = 17)) +
theme_minimal() +
theme(legend.position = "right")
ggplotly(p)
})
# Graphe Profil 2
output[[ns("graphe_profil2")]] <- renderPlotly({
res <- acm_resultats()
validate(
need(!is.null(res), "Impossible de réaliser l'ACM : vérifiez vos sélections.")
)
var_coords_actives <- as.data.frame(res$var$coord)
if (!is.null(res$quali.sup) && !is.null(res$quali.sup$coord) && nrow(res$quali.sup$coord) > 0) {
var_coords_sup <- as.data.frame(res$quali.sup$coord)
var_coords <- rbind(var_coords_actives, var_coords_sup)
var_coords$type <- c(rep("Active", nrow(var_coords_actives)),
rep("Supplémentaire", nrow(var_coords_sup)))
} else {
var_coords <- var_coords_actives
var_coords$type <- "Active"
}
colnames(var_coords) <- gsub(" ", ".", colnames(var_coords))
var_coords$label <- rownames(var_coords)
var_coords$distance <- sqrt(var_coords$Dim.2^2 + var_coords$Dim.3^2)
if (isTRUE(input[[ns("filtrer_distance")]])) {
var_coords <- subset(var_coords, distance > 1)
}
validate(
need(nrow(var_coords) > 0, "Aucune modalité avec une distance > 1.")
)
palette_couleur <- c(
"Active" = "blue",
"Supplémentaire" = "darkred"
)
p <- fviz_mca_biplot(res,
label = "none",
col.var = NA,
col.ind = "grey",
axes = c(2, 3),
repel = TRUE)
p$layers <- Filter(function(layer) {
!inherits(layer$geom, "GeomPoint") || !any(grepl("var", deparse(layer$mapping)))
}, p$layers)
p <- p +
geom_point(data = var_coords,
aes(x = Dim.2, y = Dim.3, color = type, shape = type),
size = 2) +
geom_text(data = var_coords,
aes(x = Dim.2, y = Dim.3, label = label, color = type),
size = 3, vjust = -1.8) +
scale_color_manual(values = palette_couleur) +
scale_shape_manual(values = c("Active" = 16, "Supplémentaire" = 17)) +
theme_minimal() +
theme(legend.position = "right")
ggplotly(p)
})
})
})
})
}
shiny::runApp('C:/Users/PWC4018A/Desktop/backup/test1')
install.packages("tidyverse")
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
runApp('C:/Users/PWC4018A/Desktop/backup/test1')
shiny::runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
shiny::runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('C:/Users/PWC4018A/Desktop/backup')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
shiny::runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
runApp('S:/SCD/05_PEE/05_04_Enquêtes/automatisation-graphes-R/ap')
shiny::runApp()
install.packages("shinyWidgets")
runApp()
runApp()
runApp()
runApp('~/1/1_Dash')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp()
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp('~/1/con_no_nps/ap')
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
?inputMCA
shiny::runApp()
runApp()
